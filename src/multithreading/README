1. bankExample:
В примере имитируется банк со многими счетами.
В программе случайным образом формируются транзакции, переводящие деньги с одного счета на другой.
Каждый счет владеет одним потоком.
Каждая транзакция перемещает произвольную сумму денег с одного счета на другой произвольно выбираемый счет.
Общая сумму денег банка по всем счетам должна оставаться неизменной, поскольку деньги переводятся со счета на счет,
а не снимаются окончательно.
Чтобы прекратить выполнение программы необходимо нажать комбинацию клавиш <Ctrl + F2>.
При выполнении общий баланс в течение нескольких транзакций в имитируемом банке остается равным 100000$,
но через некоторое время общий баланс изменяется.
Задание:
1) Необходимо исправить поведение программы, общий баланс не должен изменяться.
2) Необходимо добавить новый функционал. Сейчас можно снять деньги со счета, если на остатке есть достаточно средств.
   Если на остатке нет средств, транзакция должна перейти в режим ожидания, пока возможно другая транзакция не пополнит
   данный счет на недостающую сумму.
3) Пример взаимной блокировки:
       Счет 1: сумма $200
       Счет 2: сумма $300
       Поток 1: переводит сумму $300 со счета 1 на счет 2
       Поток 2: переводит сумму $400 со счета 2 на счет 1
       Потоки 1 и 2 блокируются. Ни один из них не выполнится, поскольку остатков на счетах недостаточно для выполнения транзакции

   Вопрос: почему в bankExample после реализации п.1 взаимная блокировка не может произойти?

   Необходимо изменить bankExample, чтобы произошла ситуация взаимных блокировок.
   Варианты:
   a) исключите лимит $1000 на транзакцию. Установите значение константы NACCOUNTS равным 10 (чтобы ускорить наступление
      вз. блокировки), сконструируйте объект типа Runnable со значением поля max,
      равным 2*INITIAL_BALANCE, и запустите программу на выполнение.
   b) сделайте i-й поток ответственным за размещение денег на i-м счете вместо их снятия с i-го счета.
      В этом случае имеется вероятность, что все потоки набросятся на один и тот же счет и каждый из них будет пытаться
      снять с него деньги.
   с) SignalAll() заменить на Signal()
      Пример, когда такая замена сработает:
         Счет 1: сумма $1990
         Все прочие счета: сумма $990 на каждом
         Поток 1: переводит сумму $995 со счета 1 на счет 2
         Все прочие потоки: переводят сумму $995 со своего счета на другой
         Все потоки кроме 1 заблокированы, поскольку на их счетах недостаточно денег.
         Поток 1 выполняет перевод денег:
         Счет 1: сумма $995
         Счет 2: сумма $1985
         Все прочие счета: сумма $990 на каждом
         В потоке 1 вызывается метод signal()/notify(), который произвольным образом выбирает поток для разблокировки
         Допустим, он выбирает поток 3. Этот поток активизируется, средств недостаточно, вызывается  await()/wait().
         Поток 1 продолжает работать, но если сумма перевода больше чем остаток, метод await()/wait() вызывается и для потока 1.
         В итоге все потоки заблокированы.
   d) Ваш вариант
   Когда программа зависнет, для завершения работы нажмите комбинацию клавиш <Ctrl + Break>. С помощью этой комбинации можно
   посмотреть сожержание памяти с вычислением всех потоков.
